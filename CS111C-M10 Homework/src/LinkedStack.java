import java.util.EmptyStackException;public final class LinkedStack<T> implements StackInterface<T> {	private Node topNode; 	public LinkedStack() {		topNode = null;	} 	public void push(T element) {		Node newNode = new Node(element, topNode);		topNode = newNode;		//topNode = new Node(element, topNode); // Alternate code	} 	public T peek() {		if (isEmpty()) {			throw new EmptyStackException();		} else {			return topNode.data;		}	} 	public T pop() {		T top = peek(); // Might throw EmptyStackException				// Assertion: topNode != null		topNode = topNode.next;		return top;	} 	public boolean isEmpty() {		return topNode == null;	} 	public void clear() {		while(topNode!=null) {			topNode.data = null;			topNode = topNode.next;		}	} 		public boolean priorityPush(T element) {		// check empty stack		if (isEmpty()) {			push(element);			return false;		}		// check if element already on top		if (peek().equals(element)) { // is element already on top?			return true;		}				// check to see if element is in stack		// we already know it's not the top element		Node prev, current = topNode;		boolean found = false;		do {			prev = current;			current = current.next;			if (current != null) {				found = (current.data.equals(element));			}		} while (current != null  && !found); 					if (found) {			// delete item and re-push			prev.next = current.next;			push(element);			return true;		} else {			// just push			push(element);			return false;		}	}	public T peekNext() {		// check for empty stack		peek();  // throws error if empty		// stack is not empty		if (topNode.next == null) {			throw new EmptyStackException();		} else {			return topNode.next.data;		}	}	private class Node {		private T data; 		private Node next; 		private Node(T data) {			this(data, null);		} 		private Node(T data, Node next) {			this.data = data;			this.next = next;		} 		private T getData() {			return data;		} 		private void setData(T data) {			this.data = data;		} 		private Node getNextNode() {			return next;		} 		private void setNextNode(Node next) {			this.next = next;		} 	} } 